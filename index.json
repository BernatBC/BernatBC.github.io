[{"categories":null,"contents":"The statement We are in the year 2075 and the first colonizers of Mars have established a network of bases throughout the geography of the planet that can be of two types, settlements (where the settlers live) and warehouses (where supplies arrive from the Earth). Moving between these bases is done by rovers that can move supplies and specialized personnel. It is not possible to always go directly from one base to another, we have a map (connected graph) that tells us which movements are possible.\nTo cover the needs of the settlements, they request both specialized personnel and supplies to a centralized hub. Each request is for a supply unit or a person, if you want more you can make several requests. This hub is in charge of planning the movements of the rovers from the base where they are parked, to pick up the supplies and the necessary personnel and finally to leave them in the place where the request has been made. We will assume to make things simpler that there are always more requests for supplies and personnel of those that can be used (life on Mars is very hard).\nIn thu is project they ask to write a PDDL script alongside with the Metric-FF planning system to solve the problem. We had to make both the domain and problem files.\nThe full statement is in the document below. Note that the statement is in Spanish.\nOur solution @alexland7219, @Loparc and I started making the domain file, starting with a script theat allowed us to assign the requests to thes bases. Once this worked, we added a limitation to the number of supplies and personnel that could fit in a rover (rovers don\u0026rsquo;t have infinite seats and trunk space). Then we added to the problem gas levels. First the planification system tried not to burn more gas than the available, and then me made a modification to try to burn the least amount of gas as possible. Finally we added a priority to each request. When a supply/personnel has more than one request, the one with the highest priority will get it. Our final solution, the planificator system tried to assign the highest priority requests together with optimizing the usage of the fuel.\nObjects rover - object base - object asentamiento almacen - base localizable - object persona carga - localizable Predicates (esta-en ?loc - localizable ?b - base) Indicates if a personnel/supply unit is in the indicate base. (aparcado-en ?rov - rover ?b - base) Indicates if a rover is in the indicate base. (esta-en-rover ?loc - localizable ?rov - rover) Indicates if a personnel/supply unit is in the indicate rover. (esta-en ?loc - localizable ?b - base) Indicates if a personnel/supply unit is in the indicate base. (servido ?loc - localizable) Indicates if a personnel/supply unit has reached its destination. (important-petition ?loc - localizable ?b - base) (medium-petition ?loc - localizable ?b - base) (low-petition ?loc - localizable ?b - base) Indicates if there\u0026rsquo;s a petition for a certain personnel/supply unit to the indicated base.\nFunctions (current-capacity ?rov - rover) Returns the load capacity of the rover. (gas-level ?rov - rover) Returns the available gas of the rover. (sum-petitions) Returns a value that indicates how we\u0026rsquo;re respecting the priorities. If we\u0026rsquo;ve assigned the important requests, this value will be higher. Otherwise will be lower.\nOperations entrar (?loc - localitable, ?b - base) Sets the personnel/supply unit to served. mover_rover (:?rov - rover, ?from - base, ?to - base) Moves the rover between two bases. load_persona (?rov - rover, ?loc - persona, ?b - base) Loads a personnel to the rover. load_carga (?rov - rover, ?loc - carga, ?b - base) Loads a supply unit to the rover. unload_persona(?rov - rover, ?loc - persona, ?b - base) Unloads a personnel from the rover. unload_carga (?rov - rover, ?loc - persona, ?b - base) Unloads a supply unit from the rover.\nView Code and report on Github ","date":"January 14, 2023","hero":"/posts/education/planification/hero.png","permalink":"https://www.bernatbc.tk/posts/education/planification/","summary":"The statement We are in the year 2075 and the first colonizers of Mars have established a network of bases throughout the geography of the planet that can be of two types, settlements (where the settlers live) and warehouses (where supplies arrive from the Earth). Moving between these bases is done by rovers that can move supplies and specialized personnel. It is not possible to always go directly from one base to another, we have a map (connected graph) that tells us which movements are possible.","tags":["Artificial-Intelligence","PDDL","Education"],"title":"Planification project"},{"categories":null,"contents":"The statement The progressive aging of the population is showing the importance of maintaining a set of healthy habits and promote physical exercise throughout life. When you reach a certain age it is necessary to have help to determine what types of exercises and activities are the most appropriate taking into account all factors that may affect the performance of those activities.\nBasically, we had to make a CLIPS script that after given certain information about a person, we had to output an exercise planning suitable for him/her. We were given a bunch of documents about exercises for elder people where we had to extract the information.\nThe full statement is in the document below. Note that the statement is in Spanish.\nOur solution @alexland7219, @Loparc and I started making the ontology using Protégé, an ontology editor for building intelligent systems. We specified all items involved in the problem, like the different illnesses, body parts, properties, etc. Once we had our ontology done, with the help of owl2else to convert our .owl file to a CLIPS script. Since none of us had used CLIPS, we watched a lot of videos to understand what the h*** CLIPS was and how to use it. Neither of us used a language similar in any aspect to CLIPS. At the beginning we were so lost that nothing worked. I don\u0026rsquo;t know how suddenly our script was reading the questions the user inputs. After reading these questions, we assigned properties and relations in our ontology.\nNow is when everything we tried didn\u0026rsquo;t work. We tried to print the exercisies suitable for the user, and we learned how slots worked in CLIPS. We tried many forum solutions and none worked except for one. Thankfully, that worked, but we noticed that there were repetitions. We decided we would check if that exercise was already in the slot before inserting it. We could make this work after spending 3 or 4 hours in front of the code.\nThe remaining tasks were easier, as we already knew (more or less) how clips worked. We used some formulas to decide the amount of days that user had to exercise, the amount of repetitions and the duration.\nWe calculated the number of days a week the user has to exercise using the following formula:\n$$ \\begin{aligned} \u0026amp; days = 3 + 4 * (0.3 * \\frac{activeGrade - 1}{3} + 0.1 * notSmoker + 0.6 * \\frac{110 - age}{110 - 65}) \\newline \u0026amp; where, \\newline \u0026amp; activeGrade \\to \\text{is a number between 1 and 5 that indicates how active a person is. 1: not active, 5: very active.} \\newline \u0026amp; notSmoker \\to \\text{1: if the user does NOT smoke. 0: if the user DOES smoke.} \\newline \u0026amp; age \\to \\text{age of the user.} \\end{aligned} $$\nTo calculate the amount of repetitions the user will do, we used the following one:\n$$ \\begin{aligned} \u0026amp; repetitions = \\lfloor 20 + 10 * \\frac{activeGrade}{exerciseIntensity} \\rfloor \\newline \u0026amp; where, \\newline \u0026amp; activeGrade \\to \\text{is a number between 1 and 5 that indicates how active a person is. 1: not active, 5: very active.} \\newline \u0026amp; excerciseIntensity \\to \\text{is a number between 1 and 5 that indicates how intense an exercise is. 1: not intense, 5: very intense.} \\newline \\end{aligned} $$\nTo calculate the duration of a certain exercise the user will do, we used the following formula:\n$$ \\begin{aligned} \u0026amp; duration = \\begin{cases} \\frac{baseDuration}{2} \u0026amp;\\text{if first exercise of the day}\\newline \\frac{baseDuration}{1.5} \u0026amp;\\text{if second exercise of the day}\\newline \\frac{baseDuration}{3} \u0026amp;\\text{if third exercise of the day} \\end{cases} \\newline \u0026amp; baseDuration = \\lfloor 20 + 10 * \\frac{activeGrade}{exerciseIntensity} \\rfloor \\newline \u0026amp; where, \\newline \u0026amp; activeGrade \\to \\text{is a number between 1 and 5 that indicates how active a person is. 1: not active, 5: very active.} \\newline \u0026amp; excerciseIntensity \\to \\text{is a number between 1 and 5 that indicates how intense an exercise is. 1: not intense, 5: very intense.} \\newline \\end{aligned} $$\nView Code and report on Github ","date":"December 19, 2022","hero":"/posts/education/knowledgebasedsystems/hero.png","permalink":"https://www.bernatbc.tk/posts/education/knowledgebasedsystems/","summary":"The statement The progressive aging of the population is showing the importance of maintaining a set of healthy habits and promote physical exercise throughout life. When you reach a certain age it is necessary to have help to determine what types of exercises and activities are the most appropriate taking into account all factors that may affect the performance of those activities.\nBasically, we had to make a CLIPS script that after given certain information about a person, we had to output an exercise planning suitable for him/her.","tags":["Artificial-Intelligence","Clips","Education"],"title":"Knowledge Based Systems"},{"categories":null,"contents":"The project After making the Minesweeper, I wanted to create something more elaborated. I decided to make a clone of Monopoly. Almost everybody has played at least one time to Monopoly, so I don\u0026rsquo;t need to make an introduction.\nHow it works I started with the player movement and the dice. When everything was smooth and playable, I started to make the cards. One thing I like about them is the fact that they aren\u0026rsquo;t images. Cards are rendered based in the info assigned to its cell. With this method I don\u0026rsquo;t need to be hours making each card, and if I want to change a value, I just do it once and the card will change automatically. The cash flow of each player is pretty easy to implement. The jail cell has given me headaches with the go to jail movement and several bugs I\u0026rsquo;ve already fixed. Houses and hotels were also very buggy, especially when you sold them. I also had troubles implementing the functionality of some Chance and Community Chest cards, as I had to change the way I made some functions. With the functionality of mortgages/unmortgages I learnt to access to a child object parameter in Unity. It\u0026rsquo;s a little different from most common programming languages. Be in mind that now you can have negative cash due to testing.\nThe main functionality of the game, trading, has been implemented after spending long hours in front of the computer. It wasn\u0026rsquo;t difficult, but it took a long time. The panel where you can select which properties you want to trade is generated each time using the information of the game at that stage.\nWhat\u0026rsquo;s next? Actions will be implemented in the future. I will also make the UI as it deserves. Now it\u0026rsquo;s just a couple of text boxes and buttons. I will also add a computer player by making some kind of AI. Now the bot is dumb and does not trade nor sell houses nor mortgaging. Finally, I might try to add multiplayer, probably Peer 2 Peer.\nView Code on Github for Windows 64bit ","date":"November 26, 2022","hero":"/posts/videogames/monopoly/hero.png","permalink":"https://www.bernatbc.tk/posts/videogames/monopoly/","summary":"The project After making the Minesweeper, I wanted to create something more elaborated. I decided to make a clone of Monopoly. Almost everybody has played at least one time to Monopoly, so I don\u0026rsquo;t need to make an introduction.\nHow it works I started with the player movement and the dice. When everything was smooth and playable, I started to make the cards. One thing I like about them is the fact that they aren\u0026rsquo;t images.","tags":["C#","Unity","Videogame"],"title":"Monopoly"},{"categories":null,"contents":"The statement Given a set of Power plants and Clients, find an assignation for each Client where the total benefit is the maximum. Each power plant is represented by coordinates in a map, the total production and the cost when it\u0026rsquo;s stopped and running. Each client is represented by coordinates in a map, the power consumed, the price it pays for each Mw and a compensation in the case he doesn\u0026rsquo;t get power. Also, power gets drained if the distance between a power plant and a client is farther than a certain value.\nThey ask us to solve the problem using Hill Climbing and Simulated Annealing. We also have to study how each parameter in this algorithm varies the solution and the time efficiency.\nThe full statement is in the document below. Note that the statement is in Spanish.\nOur solution @alexland7219, @Loparc and I were allowed to use AIMA, a library where both algorithms are implemented. For each algorithm we had to determine the state representation, the initial state generation, the operands and the heuristic function. By trying and studying different options, we selected the following ideas:\nState Representation We chose to represent a state with an array of c positions, where c is the number of clients. Each position represents a client and each value the power plant which the client is assigned to (can be empty). This representation is enough, but we decided to store certain parameters, so the program can run faster. We added the benefit that solution has, and some parameters needed for the heuristic function (will be explained later).\nOperands As we need a set of operands that can reach any possible solution, we started using 3 operands: Assign, unassign and swap. Assign and unassign operators are self-explanatory. Assign sets a power plant to a client (can overwrite a previous power plant assigned). Unassign removes a power plant from a client. Swap operator switches two power plants between two clients. Of course, each time we have to apply an operator, we check if it\u0026rsquo;s possible to apply it.\nLater we found that the unassign operator was never used, so we decided to remove it. That made the execution time go down a couple of seconds.\nInitial State Generation We had to make two strategies to generate the initial state, so we can compare them later on the project. As there\u0026rsquo;s a type of clients that have to have a power plant, we decided to assign all clients of this kind to a power plant.\nThe first strategy is to assign each \u0026ldquo;guaranteed\u0026rdquo; client to the closest power plant. The second one is also to assign each \u0026ldquo;guaranteed\u0026rdquo; client to a random power plant. There are cases where the initial state is not a valid solution, so we indicate to the heuristic function how many \u0026ldquo;guaranteed\u0026rdquo; clients don\u0026rsquo;t have a power plant assigned.\nHeuristic Function Our first guess was to use the benefit as the heuristic function. This worked fairy well until we noticed that the algorithm shut down all power plants. A better option would be to provide energy to as many clients as possible. After testing a lot of functions, we got\n$$ \\begin{aligned} \u0026amp; h = (dist * \\log(dist) + energy) *(nonAssignedG + 1) \\newline \u0026amp; dist = \\sum_{n=1}^{numPowerPlants}\\sum_{m=1}^{numClients} \\begin{cases} distance(powerPlants[n], clients[m]) \u0026amp;\\text{if } assigned(powerPlants[n], clients[m]) \\newline 0 \u0026amp;\\text{else } \\end{cases} \\newline \u0026amp; energy = \\sum_{n=1}^{numPowerPlants} powerPlants[n].energyLeft² \\newline \u0026amp; where, \\newline \u0026amp; powerPlants[] \\to \\text{an array containing power plants} \\newline \u0026amp; clients[] \\to \\text{an array containing clients} \\newline \u0026amp; numPowerPlants \\to \\text{number of power plants} \\newline \u0026amp; numClients \\to \\text{number of clients} \\newline \u0026amp; energyLeft \\to \\text{energy the specified power plant has available} \\end{aligned} $$\nView Code and report on Github ","date":"October 24, 2022","hero":"/posts/education/localsearch/hero.png","permalink":"https://www.bernatbc.tk/posts/education/localsearch/","summary":"The statement Given a set of Power plants and Clients, find an assignation for each Client where the total benefit is the maximum. Each power plant is represented by coordinates in a map, the total production and the cost when it\u0026rsquo;s stopped and running. Each client is represented by coordinates in a map, the power consumed, the price it pays for each Mw and a compensation in the case he doesn\u0026rsquo;t get power.","tags":["Artificial-Intelligence","Education","Java"],"title":"LocalSearch"},{"categories":null,"contents":"About the contest Each year, School of Mathematics and Statistics from Universitat Politècnica de Catalunya organizes a coding competition for all students enrolled to UPC. During 4 hours, the contestants try to solve as many coding problems as possible. A rank is made considering the number of solved problems and penalization points. For each wrong submission, they add 20 minutes to the total of time used for each solved problem. So the sooner you solve them, the better.\nAll 9 problems given are in the document below:\nMy submissions After reading all 9 problems, I decided to start with the last one as it was the easiest. It consisted of comparing two numbers, but with a twist. A number could have up to 10k digits. Because of the rush, I didn\u0026rsquo;t read this last part well and compared to Integers. I sent it, and I got a Wrong Answer. After reading it again, I understood well the problem and made the comparison using strings.\nThen I decided to try the problem number 2 in the list, which the goal was to simulate Snakes and Ladders table game. This one was straightforward to make, but a single number made me send an incorrect submission. I assigned a ladder to a wrong cell and after this fix I got it correct.\nI carried on with the fourth problem. Given a number sequence, we\u0026rsquo;d to output the maximum difference between the average and the median when excluding a number of the sequence. My first approach consisted of calculating for each sequence (after excluding each number) the median and the average. This approach gave the correct answer, but it failed, it was too inefficient. My second approach was to calculate the average one time and subtracting the \u0026lsquo;average value\u0026rsquo; for each number. After this optimization, I got the problem correct.\nThe last problem that I could solve was number 7. The goal was to count the number of arithmetic derivatives contained into a given interval. My first approach was to solve it using recursion, and worked. But once again it wasn\u0026rsquo;t efficient. After making some tests, I encountered that arithmetic derivatives follow a pattern. A number is an arithmetic derivative if it equals to a prime number powered to itself. So my second approach was just calculating the arithmetic derivatives from each prime number and checking if it follows inside the interval.\nAmong these four problems, I tried to solve two more. The eight problem consisted of implementing a data structure to insert, erase and reset strings. It also had to count the number of strings contained into in that contained a given suffix. I made it using sets, but once again it was inefficient. After the competition, some students said that they solved using trees. The third problem consisted of painting every node from a tree either blue or red. Painting in blue costs 1 per node, while painting in red costs 2 per node. The goal was to minimize the total cost of painting the tree. There is just one restriction: Each node can have, at most, one adjacent node with the same color as itself. Once again, I read the statement too fast and solved the problem without considering the restriction. I tried to apply the restriction, but I ran out of time.\nAt the end I got 4 problems right with a penalization time of 545 (including wrong submissions). I placed 16th out of 74 participants, and 13th out of 55 UPC students.\nYou can check the full rankings here.\nView Code on Github ","date":"June 15, 2022","hero":"/posts/competitions/20concursupc/hero.png","permalink":"https://www.bernatbc.tk/posts/competitions/20concursupc/","summary":"About the contest Each year, School of Mathematics and Statistics from Universitat Politècnica de Catalunya organizes a coding competition for all students enrolled to UPC. During 4 hours, the contestants try to solve as many coding problems as possible. A rank is made considering the number of solved problems and penalization points. For each wrong submission, they add 20 minutes to the total of time used for each solved problem. So the sooner you solve them, the better.","tags":["Competition","C++"],"title":"Vintè Concurs de Programació de la UPC - Semifinal 2022"},{"categories":null,"contents":"About Google Hash Code Google Hash Code is a team programming competition, organized by Google, for students and professionals around the world. It allows you to share your skills and connect with other coders as you work together to solve a problem modeled off a real Google engineering challenge! In small teams of two to four, coders all over the world will tackle the first problem through Qualification Round. Though this round is hosted online, teams can come together virtually to compete side-by-side in locally coordinated Hash Code Hubs. The top teams from this round are invited to join us for the virtual World Finals.\nThe problem You are given a list of contributors, who have already mastered various skills, and a list of projects with different skill requirements. Contributors can improve their skills by completing projects and can mentor each other to work is roles in which they couldn\u0026rsquo;t succeed on their own. Your task is to assign contributors to project roles that fit their qualifications and maximize the score for completed projects.\nFor more details, please check the problem statement.\nOur submission The team was composed with @miquelt9, @alexland7219 and I, three friends studying Computer Science at Universitat Politècnica de Catalunya. After some brainstorming, we decided to attempt to fill the first project available with the lowest skilled contributors. As soon a project has finalized, the contributors are assigned to the first project available that they can fit in. After some debugging, we decided to generate our submission files. Little did we know that they were taking forever. We were the three of us using 100% of our CPUs and waiting for the last minute to submit the files. Luckily, when submitting partial files, the score is still computed. At the end, we ended with partial submissions.\nYou can check our algorithm alongside the submission files in my Github repository.\nIn the end with our partial submission we obtained 1,477,643 points positioning ourselves in 3259 out of 10100-10200, a little better than in 2021.\nYou can check the full rankings here.\nView Code on Github ","date":"February 24, 2022","hero":"/posts/competitions/hashcode2022/hero.jpg","permalink":"https://www.bernatbc.tk/posts/competitions/hashcode2022/","summary":"About Google Hash Code Google Hash Code is a team programming competition, organized by Google, for students and professionals around the world. It allows you to share your skills and connect with other coders as you work together to solve a problem modeled off a real Google engineering challenge! In small teams of two to four, coders all over the world will tackle the first problem through Qualification Round. Though this round is hosted online, teams can come together virtually to compete side-by-side in locally coordinated Hash Code Hubs.","tags":["Competition","C++"],"title":"Google Hash Code 2022"},{"categories":null,"contents":" The project Before making this project, I\u0026rsquo;d used Unity game engine for making a couple of games like Tetris by following some Youtube tutorials. Also, I made Space Shooter during HackUPC2021, but I wasn\u0026rsquo;t on my own. Now I wanted to do a project on my own and decided to start with a simple game. Minesweeper was a good candidate as it didn\u0026rsquo;t seem too complex. I didn\u0026rsquo;t reinvent the wheel and made a clone of minesweeper.\nHow it works Basically I defined a matrix with a fixed size and with the help of a random number generator, mines are placed randomly across the board. Each cell has some parameters like a boolean to check if it has a flag, if it\u0026rsquo;s opened, an integer that determines the number of mines next to it, etc. Each state of the cell has its own sprite. When the game detects a mouse click in a cell, the game updates the cell state and shows a new sprite corresponding to its new state. This was the most complex part of this project, it wasn\u0026rsquo;t too hard. To open the adjacent cells when there\u0026rsquo;s no mine in a cell, I made a dfs algorithm.\nView Code on Github for Windows 64bit ","date":"February 11, 2022","hero":"/posts/videogames/minesweeper/hero.png","permalink":"https://www.bernatbc.tk/posts/videogames/minesweeper/","summary":"The project Before making this project, I\u0026rsquo;d used Unity game engine for making a couple of games like Tetris by following some Youtube tutorials. Also, I made Space Shooter during HackUPC2021, but I wasn\u0026rsquo;t on my own. Now I wanted to do a project on my own and decided to start with a simple game. Minesweeper was a good candidate as it didn\u0026rsquo;t seem too complex. I didn\u0026rsquo;t reinvent the wheel and made a clone of minesweeper.","tags":["C#","Unity","Videogame"],"title":"Minesweeper"},{"categories":null,"contents":" About HackUPC HackUPC is the first student hackathon in Spain. Once a year, we aim to provide a space for students of all experience levels from all around the world where they can improve and learn new skills, meet awesome people, and overall have a great experience! This year\u0026rsquo;s edition will be held in a hybrid format, meaning that you can come in person but also participate from home.\nOur project @miquelt9, @JCasahuga and I decided to participate in this hackathon in the first year of the degree. We were just competing for fun and especially to learn new things. HackUPC is a hackathon that participants are free to choose their own theme. Neither of us knew how to make any kind of frontend, but @JCasahuga and I had used Unity game engine, so we decided to develop a 2D game using it. After some brainstorming, we decided to make a space shooter.\nAll the struggles and more info can be found in Devpost, the platform where we submitted our project. Right below there\u0026rsquo;s a demo of our game, and don\u0026rsquo;t forget to check out the project on Devpost and the code on Github.\nView Project on Devpost View Code on Github for Windows 64bit ","date":"May 16, 2021","hero":"/posts/competitions/hackupc2021/hero.jpg","permalink":"https://www.bernatbc.tk/posts/competitions/hackupc2021/","summary":"About HackUPC HackUPC is the first student hackathon in Spain. Once a year, we aim to provide a space for students of all experience levels from all around the world where they can improve and learn new skills, meet awesome people, and overall have a great experience! This year\u0026rsquo;s edition will be held in a hybrid format, meaning that you can come in person but also participate from home.","tags":["Competition","C#","Unity","Videogame"],"title":"HackUPC 2021"},{"categories":null,"contents":"About Google Code Jam Google’s longest running global coding competition, Google Code Jam, calls on programmers around the world to solve challenging, algorithmic puzzles against the clock. Contestants advance through four online-hosted rounds to compete at the annual Code Jam World Finals that is held at a different international Google office each year. Each round brings new challenges, and in the end 25 contestants will have the ultimate chance to put their skills to the test, vying for cash prizes and the coveted championship title at the World Finals.\nMy submissions I started with the first problem. The goal was to compute the cost of applying reversort to a sequence of numbers. I just implemented the reversort algorithm and calculate the overall cost.\nThe second one, given a sequence of \u0026lsquo;C\u0026rsquo;, \u0026lsquo;J\u0026rsquo; and \u0026lsquo;?\u0026rsquo;, and two values representing the cost of having CJ and JC on the sequence, we had to compute the minimum cost of the sequence when replacing the question mark for Cs or Js. My first attempt was to calculate every single possible sequence, but it was too slow. Afterwards, I noticed that by putting the same character as the front one or the behind one, you always get the minimum cost.\nThe third problem was related to the first one. We had to give the result of reversort after a given sequence size and number of iterations. I just used the first problem file and added some modifications. It worked well without any struggles.\nI found the fourth problem very challenging. After given an array size and a number of questions, we had to make a median sort but with a twist. We had to guess the initial order of the sequence by asking out of three numbers what the median was. I spent hours writing in my notebook all kinds of possibilities, and finally I got an algorithm that kind of solved the problem. It uses a lot of questions and sometimes repeats itself. But at least I got some points in that problem.\nI ended so exhausted from the fourth problem, I was running out of time and it seemed so difficult that I decided not to solve the fifth problem.\nSubmissions of all problems can be checked here.\nAt the end, I got 59/100 points after 25h and 37 minutes of time penalization. I ranked 5773rd out of 37000-38000 participants.\nYou can check the full rankings here.\nView Code on Github ","date":"March 27, 2021","hero":"/posts/competitions/codejam2021/hero.png","permalink":"https://www.bernatbc.tk/posts/competitions/codejam2021/","summary":"About Google Code Jam Google’s longest running global coding competition, Google Code Jam, calls on programmers around the world to solve challenging, algorithmic puzzles against the clock. Contestants advance through four online-hosted rounds to compete at the annual Code Jam World Finals that is held at a different international Google office each year. Each round brings new challenges, and in the end 25 contestants will have the ultimate chance to put their skills to the test, vying for cash prizes and the coveted championship title at the World Finals.","tags":["Competition","C++"],"title":"Google Code Jam 2021"},{"categories":null,"contents":"About Google Hash Code Google Hash Code is a team programming competition, organized by Google, for students and professionals around the world. It allows you to share your skills and connect with other coders as you work together to solve a problem modeled off a real Google engineering challenge! In small teams of two to four, coders all over the world will tackle the first problem through Qualification Round. Though this round is hosted online, teams can come together virtually to compete side-by-side in locally coordinated Hash Code Hubs. The top teams from this round are invited to join us for the virtual World Finals.\nThe problem Given the description of a city plan and planned paths for all cars in that city, optimize the schedule of traffic lights to minimize the total amount of time spent in traffic, and help as many cars as possible reach their destination before a given deadline.\nFor more details, please check the problem statement: Our submission The team was composed with @miquelt9, @alexland7219 and I, three friends studying Computer Science at Universitat Politècnica de Catalunya. At first, we tackled the problem by counting the potential number of cars that had to go through each traffic light and assigning greater slots of time to those that had more traffic. We were running out of time and compilation errors and several bugs were flourishing. At that time, @miquelt9 had a great idea to submit a solution where all traffic lights had the same duration. This was a simple solution, definitely worse than the first one, but it saved the day!\nYou can check both algorithms programs alongside the submission files in my Github repository.\nIn the end with our simple submission we obtained 7,886,739 points positioning ourselves in 4432 out of 9004. Not bad at all for our first ever coding competition.\nYou can check the full rankings here.\nView Code on Github ","date":"February 25, 2021","hero":"/posts/competitions/hashcode2021/hero.png","permalink":"https://www.bernatbc.tk/posts/competitions/hashcode2021/","summary":"About Google Hash Code Google Hash Code is a team programming competition, organized by Google, for students and professionals around the world. It allows you to share your skills and connect with other coders as you work together to solve a problem modeled off a real Google engineering challenge! In small teams of two to four, coders all over the world will tackle the first problem through Qualification Round. Though this round is hosted online, teams can come together virtually to compete side-by-side in locally coordinated Hash Code Hubs.","tags":["Competition","C++"],"title":"Google Hash Code 2021"}]